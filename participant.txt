Iterator participant

Iterator - Iterator
 Concrete Iterator-ChatHistoryIterator
 Aggregate-ChatRoom
 Concrete Aggregate - CtrCat,Dogorithmn

Mediator participant

Mediator-chatroom
ConcreteMediator-CtrCat,Dogorithmn
Colleague-users
ConcreteColleague- user1,user2,user3

Command participant

Command- Command
ConcreteCommand -sendMessageCommand,LogMessageCommand
Invoker - Users
Receiver-ChatRoom

State participant

State-UserState
ConcreteState- Online,Offline,Busy
Context- Users
client-


1user can be in multiple chatroom


//abstract class
Pro:
Flexibility -Each user type can have completely different send/receive behavior

Cons:

extensively - duplication risk- lot of code being duplicated if the users do thing the same way.


---- choice pf Iterator ------
reason: we implemented so we can iterate through all the chat history of different chat rooms.
pro:

keep the chatroom history encapuselated wihout getting expose.

It easy to extenc.


---- choice of design pattern ----
state (behavioral design pattern)
our system already  Mediator ,Iterator,Command,state is are behavior  because it consistent and strengthn the overall design because our system is very interation focu.

 How does it positive contribut to the system ? how would it differ wihtout state,
 You would have to have if and else and swicth statement inside the usersend and userreceive function to see if a user is online ,  Offline , or busy , 
 state also makes the system more realistic
 
 how does the state improve the extensivbility of the system ?
 adding a new state only requires adding a new subclass of user state , no change to user requires.

 We integrated the State pattern into the User class. Each User maintains a reference to a UserState, such as OnlineState, OfflineState, or BusyState. 
 The pattern allows a userâ€™s behavior to change at runtime depending on their state. For example, an offline user may not receive messages, 
 while a busy user may auto-reply. The intent of the State pattern is therefore clearly demonstrated: behavior changes without conditional logic cluttering the User class.
  Since State is a behavioural pattern, it complements the other behavioural patterns in the system (Mediator, Command, Iterator).
   It improves extensibility because new states (e.g., DoNotDisturbState, InvisibleState) can be added without modifying existing code. This makes the design flexible, realistic, and easy to extend.